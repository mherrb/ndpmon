/********************************************************************************
NDPMon - Neighbor Discovery Protocol Monitor
Copyright (C) 2006 MADYNES Project, LORIA - INRIA Lorraine (France)

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Author Info:
  Name: Thibault Cholez
  Mail: thibault.cholez@esial.uhp-nancy.fr

Maintainer:
  Name: Frederic Beck
  Mail: frederic.beck@loria.fr

MADYNES Project, LORIA-INRIA Lorraine, hereby disclaims all copyright interest in
the tool 'NDPMon' (Neighbor Discovery Protocol Monitor) written by Thibault Cholez.

Olivier Festor, Scientific Leader of the MADYNEs Project, 20 August 2006
***********************************************************************************/

#include "ndpmon.h"

int DEBUG = 0;

char admin_mail[128] = "";
char syslog_facility[16] = "";
int ignor_autoconf = 0;

/* Initialize with values defined in ndpmon_defs and generated by ./configure */
char alerts_path[128] = _ALERTS_PATH_;
char config_path[128] = _CONFIG_PATH_;
char cache_path[128] = _CACHE_PATH_;
char dtd_path[128] = _CACHE_DTD_PATH_;
char dtd_config_path[128] = _CONFIG_DTD_PATH_;
char discovery_history_path[128] = _DISCOVERY_HISTORY_PATH_;

struct action_selector action_low_pri, action_high_pri;
int use_reverse_hostlookups;

#ifdef _MACRESOLUTION_
manufacturer_t *manuf = NULL;
#endif

int learning = 0;

#if 0
static FILE *dat = NULL; /* for the discovery stats */
#endif

pthread_t event_queue_thread;
pthread_t main_thread;
/* A flag to know if we are already cleaning
 * But dangerous as it works but can lead to seg fault is threads are not well synchronized */
/* static volatile int cleaning = 0; */

void usage()
{
	fprintf(
		stderr,
		"Usage: ndpmon [ -i interfacename ] [ -f config_file ] [-e config-dtd] [ -F filter ] [ -n number ] [ -L ]  [-g neighbor_file] [-d neighbor_dtd] [-v] [-h]\nPlease refer to manpage for more details.\n");
	exit(1);
}


void handler(int n)
{
	fprintf(stderr, "\nInterrupted ;) \n");

	/* cleanup: */
	teardown();
	exit(0);
}


void setup(char *interface)
{
	int pthread_event_res;

	if (extensions_register_handlers()!=0) 
	{
		fprintf(stderr,"Error registering event handlers.\n"); exit(1);
	}

	if (extensions_register_types()!=0) 
	{
		fprintf(stderr,"Error registering extension information types.\n"); exit(1);
	}

#ifdef _COUNTERMEASURES_
	/* Countermeasures plugin init */
	cm_init(); 
#endif

	/* opening and parsing the configuration xml files*/
	if (parser_config_parse()==-1) 
	{
		fprintf(stderr, "Error parsing configuration.\n"); exit(1);
	}

	/* loading the neighbor cache for each interface */
	if (parser_neighbors_parse()==-1) 
	{
		fprintf(stderr, "Error parsing neighbor cache.\n"); exit(1);
	}
	probe_list_set_addresses();

	if (DEBUG) 
	{
		probe_list_print();
	}

	/* enable alerts if not in learning phase */
	alert_set_active(!learning);

	/* init watch functions */
	if (extensions_register_watchers()!=0) 
	{
		fprintf(stderr,"Error registering watch functions.\n"); exit(1);
	}

	if(DEBUG)
	{
		watchers_print();
	}

	pthread_event_res = pthread_create(&event_queue_thread, NULL, event_queue_run, NULL);
	if (DEBUG) 
	{
		if (pthread_event_res==0) 
		{
			fprintf(stderr, "[main] thread event_queue started.\n");
		} else 
		{
			fprintf(stderr, "[main] thread event_queue create failed.\n");
		}
	}

	/* REMOVED the following because the neighbor stats must be changed
	 * in order to work with multiple interfaces.
	 */
#if 0
	/* Now we have parsed the cache file, we can init the history stat file */
	/* Write in discovery_history.dat the number of neighbors in the cache for statistics */
	if( (dat = fopen(discovery_history_path,"w")) != NULL)
	{
		fprintf(dat,"%d %d\n", (int)time(NULL), nb_neighbor(neighbors) );
		fclose(dat);
	}
#endif

	extensions_setup(interface);
	fprintf(stderr,"------------------\n\n");

}


void teardown()
{
	/* Only the main thread cleans */
	/* dangerous as it works but can lead to seg fault is threads are not well synchronized */
	/*
	if (!cleaning)
		cleaning = 1;
	else
		return;
	*/
	if(pthread_self() != main_thread)
		return;

	fprintf(stderr, "Cleaning before exiting...\n");
	syslog(LOG_NOTICE, "NDPMon stopped.");
	closelog();

	capture_down_all();
	probe_list_send_down_event();
	event_queue(EVENT_TYPE_EXIT, NULL);
	
	if (DEBUG) 
	{
		fprintf(stderr, "Waiting for event queue to finish...\n");
	}
	pthread_join(event_queue_thread, NULL);

	extensions_teardown();

	if(learning)
	{
		parser_config_store();
	}
	parser_neighbors_store();

	/* free data structures */
	probe_list_free();
	event_handler_list_free();
	extinfo_type_list_free();
	watchers_free();
}


int main(int argc,char **argv)
{ 
	char *interface; /* name of the interface/device to use */ 

	int op = 0;

	interface = NULL;

	fprintf(stderr,"----- Initialization -----\n");

	while ((op = getopt(argc, argv, "i:vhF:n:f:e:g:d:L")) != -1)  /* former EOF changed to -1*/
	{
		switch (op)
		{

			case 'i':
				interface = optarg;
				fprintf(stderr,"interface: %s \n", interface);
				break;
				/*case 'F':
				  filter = optarg;
				  fprintf(stderr,"filter expression: %s \n", filter);
				  break;
				  case 'n':
				  nb_packet = atoi(optarg);
				  fprintf(stderr,"nb packets: %d \n", nb_packet);
				  break;*/
			case 'f':
				strncpy(config_path,optarg, PATH_SIZE);
				fprintf(stderr,"config file path: %s \n", config_path);
				break;
			case 'e':
				strncpy(dtd_config_path, optarg, PATH_SIZE);
				fprintf(stderr,"config dtd file path: %s \n", dtd_config_path);
				break;
			case 'g':
				strncpy(cache_path, optarg, PATH_SIZE);
				fprintf(stderr,"cache file path: %s \n", cache_path);
				break;
			case 'd':
				strncpy(dtd_path, optarg, PATH_SIZE);
				fprintf(stderr,"neighbor dtd file path: %s \n", dtd_path);
				break;
			case 'L':
				learning = 1;
				fprintf(stderr,"NDPMon starts in LEARNING mode.\n");
				break;

			case 'v':
				DEBUG = 1;
				fprintf(stderr,"NDPMon starts in DEBUG mode.\n");
				break;

			case 'h':
				usage();
				break;

			default:
				usage();
				break;
		}
	}

	signal(SIGINT,handler);
	signal(SIGQUIT,handler);
	signal(SIGTERM,handler);

	if (DEBUG) 
	{
		fprintf(stderr, "NDPMon was built on " __DATE__ " at " __TIME__ ".\n\n");
	}

	main_thread = pthread_self();

	setup(interface);
	capture_up_all();

	teardown();

	fprintf(stdout, "Finished! \n");

	return 0;

}


